Supongo que tengo acceso a una constante `BLOCK_SIZE` o tengo los datos necesarios para calcularlo.

```c++
int* find_file_less_size(char * dir, int min_bytes, char *
arch_nombre){
    std::vector<int> lista;
    find_file_less_size_aux(dir,min_bytes, arch_nombre, lista);
    return vector_to_array(lista);
}

int* vector_to_array(std::vector<int> vec) {
    int* arr = malloc(vec.size());  
    for (size_t i = 0; i < vec.size(); ++i) {
        arr[i] = vec[i];            
    }
    return arr; 
}

void find_file_less_size_aux(char * dir, int min_bytes, char *
arch_nombre, std::vector<int> &lista){
    struct Ext2FSInode* inodo = inode_for_path(dir);

    unsigned int numero_de_bloques_en_dir = inodo-> size/ BLOCK_SIZE + (inodo-> size % BLOCK_SIZE == 0); 

    unsigned int bytes_leidos = 0; 

    // Reservo la memoria para leer los bloques. 
    // Como las dir_entries son de longitud variable puede pasar que una entrada este partida entre dos bloques. Por lo tanto hay que leer de a dos bloques. 
    unsigned int *puntero_bloques = malloc(BLOCK_SIZE * 2);

    unsigned int left_block_address = get_block_address(inodo,0);
    read_block(left_block_adress, puntero_bloques);  
    
    int cantidad_bloques_a_leer_por_it = BLOCK_SIZE * 2;

    for(int i = 0; i < numero_de_bloques_en_dir; i++){

        if(i != numero_de_bloques_en_dir - 1){
            unsigned int right_block_address = get_block_address(inodo,i+1);
            read_block(right_block_address, puntero_bloques + BLOCK_SIZE);
        }
        else{
            puntero_bloques = realloc(puntero_bloques, BLOCK_SIZE);
            cantidad_bloques_a_leer_por_it = BLOCK_SIZE;
        }

        if(bytes_leidos > cantidad_bloques_a_leer_por_it){
            bytes_leidos = bytes_leidos % cantidad_bloques_a_leer_por_it;
        }
        
        while(bytes_leidos < cantidad_bloques_a_leer_por_it){
            struct Ext2FSDirEntry * dir_entry_actual = (struct Ext2FSDirEntry *) puntero_bloques;

            struct Ext2FSInode* inodo_actual = load_inode(dir_entry_actual->inode);
            if(inodo_actual->size < min_bytes && !strcmp(arch_nombre, dir_entry_actual->name)){ 
                lista.push_back(dir_entry_actual->inode);
            }

            if(dir_entry_actual->file_type == 0){ // Asumo que el cero es el file type de directorio
                // Le agrego al path el directorio y llamo recursivamente 
                char* directorio = strcat("/", dir_entry_actual->name);
                char* nombre = strcat(dir, directorio);
                find_file_less_size_aux(nombre, min_bytes, arch_nombre, lista);
            }

            puntero_bloques += dir_entry_actual->record_length;
            bytes_leidos += dir_entry_actual->record_length;
        }
    }

    free(puntero_bloques); 
}
```

## Punto B
Si quiero hacer que la funcion dentro de la lista devuelva: la información de cada tipo de
archivo encontrado (regular, binario, bloques, directorio, etc), su última fecha de modificación, su tamaño, y su propietario. Debería armarme un struct que tenga todos estos datos y en vez de solamente hacer append del numero del inodo en cada paso debería crear el struct con los datos asociados y appendearlo. 

El tipo de archivo lo puedo sacar de `dir_entry_actual`. 

Y su última fecha de modificación, su tamaño, y su propietario los puedo sacar de `inodo_actual`. 

## Punto C

Tenemos varios problemas con los enlaces simbolicos. 

Primero en mi codigo no estoy checkeando si los archivos son enlaces simbolicos, habria que agregar un checkeo extra. 

Tambien si tenemos que considerar los enlaces simbolicos para navegar por los directorios podemos tener problemas con la recursion. Porque puedo estar viendo en un directorio mas abajo del arbol y por medio de un symlink puedo recorrer directorios que yo ya recorri previamente, agregando al resultado elementos repetidos y pudiendo llegar a tener un ciclo infinito. 

Otra cosa que habria que agregar es que si quiero empezar a leer los enlaces simblicos tengo que agregar operaciones para acceder al path del enlace simbolico leyendo el primer bloque de datos del inodo y extrayendo el path. 